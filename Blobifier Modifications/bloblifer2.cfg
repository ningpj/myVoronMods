#####################################################################################################################################                                                                        
;                  ██████╗ ██╗      ██████╗ ██████╗ ██╗███████╗██╗███████╗██████╗     ██████╗     ██████╗ 
;                  ██╔══██╗██║     ██╔═══██╗██╔══██╗██║██╔════╝██║██╔════╝██╔══██╗    ╚════██╗   ██╔═████╗
;                  ██████╔╝██║     ██║   ██║██████╔╝██║█████╗  ██║█████╗  ██████╔╝     █████╔╝   ██║██╔██║
;                  ██╔══██╗██║     ██║   ██║██╔══██╗██║██╔══╝  ██║██╔══╝  ██╔══██╗    ██╔═══╝    ████╔╝██║
;                  ██████╔╝███████╗╚██████╔╝██████╔╝██║██║     ██║███████╗██║  ██║    ███████╗██╗╚██████╔╝
;                  ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝    ╚══════╝╚═╝ ╚═════╝ 
#####################################################################################################################################                                                                        
#
# Do away with purge blocks for ever!! Macros and configuration for the Blobifier filament purge, waste tray and nozzle scrubber system.
#
# This project was created and led by Dendrowen (@dendrowen on Discord) and has continued to evolve with community input with pulsating
# purge mechanism to quickly purge and clear colour from the hotend with minimal filament wastage; support for left (default) and right 
# hand installations (at max.y); coordinated use of different combinations of static (bed level) and gantry mounted silicon nozzle
# wiping and rest options, zigzag, straight-line, and combo nozzle scrubbing actions, nozzle shaker and other QOL improvements to help 
# mitigate ooze and colour contamination when swapping filaments.
#
# The macros are designed for use with a Voron 2.4 flying gantry setup and were originally developed for a Voron v2.4 300mm printer.
# It's now a popular (some would say mandatory) addition to any Voron v2.4 used for multi-colour printing and MMU's like ERCF,
# Tradrack, Angry Beaver, Box Turtle, etc.
#
# Head on over and join the Happy Hare MMU discord community here (https://discord.gg/DZQWJhVH). Blobifier STL's, CAD and assembly
# instructions are available on the Blobifier GitHub (https://github.com/Dendrowen/Blobifier). 
#
# Special thanks to contributions from:
#
#  > hernsl (hernsl#8860 on Discord) for the original nozzle scrubber and macros this project was based around
#  > igiannakas for helping develop and champion the pulsating purge action and gantry nozzle wipe and rest concept
#  > others???
#  > ningpj for macro refinements, right-hand installation options and redesign of nozzle wipe/rest solutions
#
#
# *** Important Notice ***
# ========================
# Portions of your bed and print area are unusable when using Blobifier as the toolhead needs to descend to the bed to poop
# excess filament from the system & wipe/park. It can be installed on either side of the printer (left-rear or right-rear), making
# a small section in the corner unavailable. If you are concerned about losing print volume you can minimise this by electing 
# not to install the static nozzle wipe/rest that extends over the purge tray. For best results however, it is recommended to 
# use both options in combination especially when printing tall MMU parts. Use of various nozzle wipe/rest options is controlled
# through Blobifier settings. The macros assume Blobifier has been installed at max.y of your printer which lines up with the
# centre of the purge tray and nozzle wiper/rest options you want to use. It’s also highly recommended to mask and define 
# exclusion zones in your slicer to prevent placement of parts that would prevent Blobifier from descending.
# Blobifier leverages and automatically parses moonraker object tags to work out if it’s safe to descend and will calculate
# and display the slicer bed exclusion polygon on startup for you to paste into your slicers printer definition. 
# e.g 265x278, 300x278, 300x310, 265x310
#
# Move and wipe options are optimised according to Blobifier orientation and enabled wiper/rest options. In general moves are 
# optimised to move away from the tray and through the wiper to the rest if configured. The following configurations are supported:
#
# Combined gantry wiper:  Preferred nozzle park/rest location and final wipe as the gantry doesn’t need to descend. 
# and rest (optional)     Nozzle should also be parked here when the print is paused, ends or is cancelled. 
#
# Static wiper and rest:  2nd preferred option when changing filament, while paused, etc. The gantry needs to descend to the bed and
# (optional)              will do so provided OBJECT_PROCESSING is enabled and it can safely (only in print). Wiper and/or rest options 
#                         can be enabled separately to suit requirements e.g. rest only, wiper only, rest and wiper
#
# Tray:                   This is the fall back when neither wiper/rest options are installed. As per static wiper/rest, the gantry
#                         needs to be able to descend to the bed
#
# Coordinated Blobifier parking moves in Happy Hare are enabled by setting the following in mmu_macro_vars.cfg. If you are a Klicky 
# user and concerned about potential probe/gantry collisions while attached and blobbing, alternate macro entry points are provided
# to check if the klicky probe is unexpectedly attached and bypass blobbing. Please note you can call the safe wrapper macros
# without Klicky or Klicky macros installed:
#
# Parking:                user_park_move_macro     : 'BLOBIFIER_PARK' or 'BLOBIFIER_SAFE_PARK' for Klicky users
# Purging Blobbing:       user_post_load_extension : 'BLOBIFIER'      or 'BLOBIFIER_SAFE' for Klicky users
#
# Project Goals
# =============
# Optimise purging and disposal process when changing filament during multicolour prints. Removing the need and reclaim print area lost
# to purge blocks and minimise filament waste during swaps. Blobifier achieves this by purging onto a retractable tray and creating
# a series of tiny blobs (poops) that are collected in a bucket under the bed. Depending on the size of the v2.4 Voron printer, the bucket
# can hold up to 400+ filament blobs for a 300mm sized printer tray (** varies, depending on purge volumes and number of light to dark
# filament changes required by the print). The print will pause and you will be prompted to empty the bucket when full.
#
# Installation and Usage
# ======================
#
# Refer to installation and configuration notes at https://github.com/Dendrowen/Blobifier 
#
# *********************************************************  DISCLAIMER  ************************************************************
#
# You, and you alone are responsible for the correct configuration and use of these macros and gcode. Any damage that may occur to
# your person or printer remains your responsibility. When setting up and executing the macros for the first times, make sure you
# observe the process and behaviour closely and keep your finger on the emergency stop button!!! 
#
#                                        All care, no responsibility, use at own risk :-)
#
# *********************************************************  DISCLAIMER  ************************************************************
 
[include ../mmu/addons/blobifier_hw.cfg] # Include servo hardware definition separately to allow for automatic upgrade
[exclude_object]                         # Make sure exclude objects are enabled if not already defined elsewhere 
 
#####################################################################################################################################                                                                                                                              
; ██████╗ ██╗      ██████╗ ██████╗ ██╗███████╗██╗███████╗██████╗     ███████╗███████╗████████╗████████╗██╗███╗   ██╗ ██████╗ ███████╗
; ██╔══██╗██║     ██╔═══██╗██╔══██╗██║██╔════╝██║██╔════╝██╔══██╗    ██╔════╝██╔════╝╚══██╔══╝╚══██╔══╝██║████╗  ██║██╔════╝ ██╔════╝
; ██████╔╝██║     ██║   ██║██████╔╝██║█████╗  ██║█████╗  ██████╔╝    ███████╗█████╗     ██║      ██║   ██║██╔██╗ ██║██║  ███╗███████╗
; ██╔══██╗██║     ██║   ██║██╔══██╗██║██╔══╝  ██║██╔══╝  ██╔══██╗    ╚════██║██╔══╝     ██║      ██║   ██║██║╚██╗██║██║   ██║╚════██║
; ██████╔╝███████╗╚██████╔╝██████╔╝██║██║     ██║███████╗██║  ██║    ███████║███████╗   ██║      ██║   ██║██║ ╚████║╚██████╔╝███████║
; ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚═╝╚═╝     ╚═╝╚══════╝╚═╝  ╚═╝    ╚══════╝╚══════╝   ╚═╝      ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚══════╝
#####################################################################################################################################                                                                                                                              
 
# Main macro and user defined settings. You should only need to call this or trigger it from Happy Hare in the _MMU_POST_LOAD macro by
# updating MMU_MACRO_VARS.cfg and setting variable_user_post_load_extension : 'BLOBIFIER'
 
# Notes on BLOBIFIER macro parameters:
# PURGE_LENGTH=[float] (optional) The length to purge. If omitted (default) it will check the purge_volumes matrix or 
# variable_purge_length parameter to determine the amount to purge. This parameter can be used to override settings for testing.
#
[gcode_macro BLOBIFIER] # Main Blobifier macro with user defined parameters to define the setup and control the filament purge process.
# Note retractions are managed by Happy Hare and defined in 'mmu_macro_vars.cfg' which should be adjusted if you are experience oozing.
 
variable_purge_spd             :  9       # Speed, in mm/sec, for purge.   
variable_purge_temp_min        :  230     # Minimum nozzle purge temperature.
variable_toolhead_x            :  30      # mm from nozzle tip to the left / right of your printhead (safety margin).
variable_toolhead_y            :  28      # mm from nozzle to the front of your printhead (safety margin).
 
# This macro will prevent a gcode movement downward while 'blobbing' if there might be a print in the way
# (e.g. You print something large and need the area where Blobifier does its... 'business'). However, at low heights (or at print start) 
# this might not be desirable. You can force a 'safe descend' with this variable. Keep in mind that the height of the print is an 
# estimation based on previous heights and certain assumptions so it might be wise to include a safety margin of 0.2mm
variable_force_safe_descend_height_until: 0.2
 
# These parameters define your scrubbing, travel speeds, safe z clearance and how many times you want to wipe. Update as necessary.
variable_clearance_z           :  3        # Minimum clearance along z when traveling, but not cleaning between nozzle & brush.
variable_travel_spd_xy         :  800      # Travel speed when not wiping along xy in mm/sec. 
variable_travel_spd_z          :  40       # Travel speed when not wiping along z in mm/sec.  
variable_wipe_spd_xy           :  1000     # Nozzle wipe speed along x in mm/sec. zigzag set to 60% or max of 500mm/s to prevent damage.
 
# The acceleration to use when parking and wiping. Set to -1 to disable and use the printer’s last/current acceleration settings.
# However this may be too conserative and slow. Set to 0 to override and use the currently defined 
# printer.configfile.config.printer.max_accel setting, or set to a higher or specific value you want to use. If > current 
# printer.configfile.config.printer.max_accel, Blobifier will display a warning on startup. Overriden and tested with 10000 accels.
variable_wipe_accel            :  0
 
# Blobifier sends the toolhead to max.y during purge / park operations and min.x / max.x depending on its orientation when shaking
# the tray. This can cause issues when Klipper skew correction is enabled. If you have and are seeing 'move out of range' errors
# when Blobifier is triggered, try adjusting and increasing this value to move a small margin away from print limits.
# Blobifier enforces a maximum value of 1.0mm. Start with 0.1mm and increase until you no longer get 'move out of range' errors.
variable_skew_correction       :  0
 
# These parameters define the size of the static brush / silicon wiper. Update as necessary. A visual reference is provided below.
# NOTE, All X settings are expressed from the left of the printer, regardless of Blobifier install orientation.
 
#                   ←  wiper width  →
#                   _________________
#                  |                 |  ↑              The Y position is assumed to be stepper_y max - skew_correction.
#  wiper start (x) |                 |   max_y         Adjust the wipers physical y position so the nozzle is centred.
#                  |_________________|  ↓              If zigzag wiping is enabled, position it so the nozzle is more towards
#                                                      the back of the wiper as it zigs 2mm away from max.y when wiping.
# __________________________________________________________
#                     PRINTER FRONT
 
# Blobifier prioritises and selects the optimal parking location based on what's configured as follows. 
# Wipe and park locations are independent and optional and will fall back to parking on the tray if no better option is available.
# and can be enabled | disabled to suit requirements. Also, when setting the height for the static wiper, be careful not to set it
# too low especially with a silicon brush!! Start higher and progressively lower.
 
# 1) Park on Gantry nozzle rest if fitted
# 2) Park on Static nozzle rest if fitted
# 3) Fallback and park on purge tray
 
variable_static_park           :  229.5, 1.3           # x from left, park height. Set x to -1 to disable.
variable_static_wiper          :  234, 39, 1.2, 2, 1   # x from left, wiper width, wiper height, wipe pattern 
                                                       #   [0: straight, 1: zigzag], & back and forth iterations. Set x to -1 to disable.
variable_gantry_park           :  121.6                # x from left. Set x to -1 to disable.
variable_gantry_wiper          :  126, 42, 2, 3        # x from left, wiper width, wipe pattern [0: straight, 1: zigzag], 
                                                       #   & back and forth iterations. Set x to -1 to disable.
 
# Location on the tray to purge blobs. The tray is 15mm in length, so if you assemble it against either side of the bed,
# 10mm +/- min.x or max.x depending on the orientation is a good starting point. E.g. 10 for LH, max.x - 10 for RH setups.
variable_purge_x               :  295
 
# Height of the tray. If it's below your bed, set this to a negative number. If it's above the bed, set to a positive number.
# Determine this by homing, performing a QGL or equivalent and manually moving the toolhead and nozzle until its above the tray, 
# and lowering the print head using a piece of paper as you would to set your z-offset.
# NOTE - Unlike the print bed, the Blobifier tray can move a little in height so need to make sure you don't set it too low
#        and causing the tray to collide / catch the nozzle when its retracted / extended to help detach completed blobs.
variable_tray_top              :  0.2
 
# Servo angles for tray positions
# NOTE - The angles will be reversed if you have installed Blobifier on the RH side of your printer. 
variable_tray_angle_out        :  180                 # The angle when extended
variable_tray_angle_in         :  0                   # The angle when retracted
variable_dwell_time            :  300                 # The time in ms to wait for the servo to finish extending / retracting the tray.
 
 
; ██████╗ ██╗      ██████╗ ██████╗     ████████╗██╗   ██╗███╗   ██╗██╗███╗   ██╗ ██████╗
; ██╔══██╗██║     ██╔═══██╗██╔══██╗    ╚══██╔══╝██║   ██║████╗  ██║██║████╗  ██║██╔════╝
; ██████╔╝██║     ██║   ██║██████╔╝       ██║   ██║   ██║██╔██╗ ██║██║██╔██╗ ██║██║  ███╗
; ██╔══██╗██║     ██║   ██║██╔══██╗       ██║   ██║   ██║██║╚██╗██║██║██║╚██╗██║██║   ██║
; ██████╔╝███████╗╚██████╔╝██████╔╝       ██║   ╚██████╔╝██║ ╚████║██║██║ ╚████║╚██████╔╝
; ╚═════╝ ╚══════╝ ╚═════╝ ╚═════╝        ╚═╝    ╚═════╝ ╚═╝  ╚═══╝╚═╝╚═╝  ╚═══╝ ╚═════╝
 
# The following section defines how the purging sequence is executed. This is where you tune the purging to create pretty blobs.
# Refer to the visual reference for a better understanding. The visual is populated with example values. Below are some guides
# provided to help with tuning.
#
#                          \_____________/
#                             |___|___|
#                                \_/            ______________  < End of third iteration.
#                                / \                                  HEIGHT:   3 x iteration_z_raise - (2 + 1) x iteration_z_change  (3 x 5 - 2 x 1.2 = 11.4)
#                               |   |                                 EXTRUDED: 3 x max_iteration_length                              (3 x 50 = 150)
#                              /     \          ______________  < End of second iteration.
#                             |       \                               HEIGHT:   2 x iteration_z_raise - 1 x iteration_z_change        (2 x 5 - 1 x 1.2 = 8.8)
#                            /         |                              EXTRUDED: 2 x max_iteration_length                              (2 x 50 = 100)
#                           |           \       ______________  < End of first iteration.
#                          /             \                            HEIGHT:   1 x iteration_z_raise                                 (1 x 5 = 5)
#                         |               |                           EXTRUDED: 1 x max_iteration_length                              (1 x 50 = 50)
#___________               \             /      ______________  < Start height of the nozzle. default value: 1.5mm
#           |_______________\___________/_      ______________  < Bottom of the tray
#           |_____________________________|
#
########################### BLOB TUNING ##############################
# +-------------------------------------+----------------------------+
# |  Filament sticks to the nozzle at   | Incr. purge start          |
# |    initial purge (first few mm)     |                            |
# +-------------------------------------+----------------------------+
# |  Filament scoots out from under     | Incr. temperature          |
# |  the nozzle at the first iteration  | Decr. z_raise              |
# |                                     | Incr. purge_length_maximum |
# +-------------------------------------+----------------------------+
# |  Filament scoots out from under the | Decr. purge_spd            |
# |  the nozzle at later iterations     | Decr. z_raise_exp          |
# |                                     | Decr. z_raise              |
# |                                     | Incr. purge_length_maximum |
# +-------------------------------------+----------------------------+
# |  Filament sticks to the nozzle at   | Incr. z_raise_exp          |
# |         later iterations            |     (Not above 1)          |
# +-------------------------------------+----------------------------+
 
# The height to raise the nozzle above the tray before purging. This allows any built up pressure to escape before the purge.
variable_purge_start           :  0.0
 
# The amount to raise Z
variable_z_raise               :  12.6 
 
# As the nozzle gets higher and the blob wider, the Z raise needs to be reduced, this follows the following formula:
#            (extruded_amount/max_purge_length)^z_raise_exp * z_raise
# 1 is linear, below 1 will cause z to raise less quickly over time, above 1 will make it raise quicker over time. 0.85 is a
# good starting point and you should not have it above 1
variable_z_raise_exp           :  0.85
 
# Lift the nozzle slightly after creating the blob to release pressure on the tray.
variable_eject_hop             :  1.0 
 
# Dwell time (ms) after purging and before cleaning to relieve pressure from the nozzle.
variable_pressure_release_time :  1000 
 
# Set the part cooling fan speed. Disabling can help prevent the nozzle from cooling down and stimulate flow, Enabling it can 
# prevent blobs from sticking together. Values range from 0 .. 1, or -1 if you don't want it changed.
variable_part_cooling_fan      :  0.5        
 
# ========================================================================================
# PURGE LENGTH SETTINGS
# ========================================================================================
 
# The absolute minimum to purge, even if you don't changed tools. This is to prime the nozzle before printing.
variable_purge_length_minimum  :  30
 
# The maximum amount of filament (in mm) to purge in a single blob. Blobifier will automatically purge multiple blobs if the 
# required purge amount exceeds this.
variable_purge_length_maximum  :  150
 
# Default purge length to fall back to when neither the tool map purge_volumes or parameter PURGE_LENGTH are set.
variable_purge_length          :  70
 
# The slicer values often are a bit too wasteful. Tune it here to get optimal values. 0.6 (60%) is a good starting point.
variable_purge_length_modifier :  0.55
 
# Fixed length of filament to add after the purge volume calculation. Happy Hare already shares info on the extra amount of 
# filament to purge based on known residual filament, tip cutting fragment and initial retraction setting. However this setting 
# can add a fixed amount on top on that if necessary although it is recommended to start with 0 and tune slicer purge matrix first.
# When should you alter this value:
#   INCREASE: When the dark to light swaps are good, but light to dark aren't.
#   DECREASE: When the light to dark swaps are good, but dark to light aren't. Don't
#     forget to increase the purge_length_modifier
variable_purge_length_addition :  0
 
# ========================================================================================
# BUCKET SETTINGS
# ========================================================================================
 
variable_max_blobs             :  500                 # Max # blobs in bucket. Pause print if exceeded and prompt for bucket to be emptied. 
variable_enable_shaker         :  1                   # Enable the bucket shaker to distribute blobs
variable_bucket_shakes         :  14                  # Number of shakes to distribute blobs

# The acceleration to use when shaking the bucket to distribute blobs. Set to -1 to disable and use the printer’s last/current 
# acceleration settings. However this may be too conserative and slow. Set to 0 to override and use the currently defined 
# printer.configfile.config.printer.max_accel setting, or set to a higher or specific value you want to use. If > current 
# printer.configfile.config.printer.max_accel, Blobifier will display a warning on startup. Overriden and tested with 10000 accels.
variable_shake_accel           :  0               
 
# The frequency at which to shake the bucket. A decimal value ranging from 0 to 1, where 0 is never, and 1 is every time. This way
# the shaking occurs more often as the bucket progressively fills up. Sensible values range from 0.75 to 0.95
variable_bucket_shake_frequency:  0.95
variable_shaker_arm_z          :  3                   # Height of the shaker arm. Increase to clear tray 
 
# Nozzle shaker settings and distance and number of iterations to shake the nozzle along x axis. Shaking starts from 
# the purge position and moves away and back with tray extended help detach belligerent blobs. 
# Max 6mm motion from purge_x location. 
variable_nozzle_shaker         :  5, 4                # x move distance, & complete iterations. Set to -1 to disable.
variable_tray_iterations       :  1                   # The number of times to retract and extend the tray to help detach blobs. Defaults to 1.
 
 
# Internal Use Only, do not change
variable_orientation           :  -1                  # internal set using purge.x position to optimise LH/RH move/wipe actions
variable_macro_auth            :  -1                  # internal ephemeral random number to restrict access to non-interactive macros 
 
 
 # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    BLOBIFIER MACRO    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
gcode:
  SAVE_GCODE_STATE NAME=BLOBIFIER_state  
  {% set g2g = True %}
 
  {% if "xyz" not in printer.toolhead.homed_axes or (printer.quad_gantry_level and printer.quad_gantry_level.applied == False) %}  # bail if not homed or QGL'd
     {action_respond_info("BLOBIFIER: Not homed or QGL not applied! Please home xyz and QGL")}
     {% set g2g = False %}
  {% elif (gantry_park > 0 or gantry_wiper[0] > 0) and printer["gcode_macro _User_Variables"] is defined %}  # bail if gantry wipe / rest and klicky probe is attached to avoid collision  
     {% if printer["gcode_macro _Probe_Variables"].probe_attached %}
        {action_respond_info("BLOBIFIER: Unexpected Klicky probe attached! Please remove to avoid collision with gantry wiper / rest")}
        {% set g2g = False %}
     {% endif %}
  {% endif %} 
    
  {% if g2g %}  # good to go ?
     {% if part_cooling_fan >= 0 %}  # override part cooling fan if required
        M106 S{part_cooling_fan * 255}
     {% endif %}
 
     M220 S100  # override feed-rate to 100% for purge
 
     {% set sequence_vars          = printer['gcode_macro _MMU_SEQUENCE_VARS'] %}
     {% set park_vars              = printer['gcode_macro _MMU_PARK'] %}
     {% set filament_diameter      = printer.configfile.config.extruder.filament_diameter|float %}
     {% set filament_cross_section = (filament_diameter/2) ** 2 * 3.1415 %}
     {% set from_tool              = printer.mmu.last_tool %}
     {% set to_tool                = printer.mmu.tool %}
     {% set bl_count               = printer['gcode_macro _BLOBIFIER_COUNT'] %}
     {% set safe                   = printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'] %}
     {% set ignore_safe            = safe.print_height < force_safe_descend_height_until %}
     {% set restore_z              = [printer['gcode_macro BLOBIFIER_PARK'].restore_z,printer.gcode_move.gcode_position.z]|max %}
       
     # Get purge volumes from the slicer (if set up right. see
     # https://github.com/moggieuk/Happy-Hare/wiki/Gcode-Preprocessing)
     {% set pv = printer.mmu.slicer_tool_map.purge_volumes %}
 
 
     # ==============================  DETERMINE PURGE VOLUME  ===============================
 
     {% if params.PURGE_LENGTH %}  # purge if length provided as argument e.g. invoked directly
        {action_respond_info("BLOBIFIER: param PURGE_LENGTH provided")}
        {% set purge_len = params.PURGE_LENGTH|float %}
     {% elif from_tool == to_tool and to_tool >= 0 %}  # dont purge if the tool hasnt changed
        {action_respond_info("BLOBIFIER: Tool didn't change (T%s > T%s), %s" % (from_tool, to_tool, "priming" if purge_length_minimum else "skipping"))}
        {% set purge_len = 0 %}
      {% elif pv %}  # else grab purge matrix from Happy Hare (likely from slicer)
        {% if from_tool < 0 and to_tool >= 0%}  # unknown from tool?  find max purge value for target tool 
           {action_respond_info("BLOBIFIER: unknown source tool. Finding largest value for T? > T%d" % to_tool)}
        {% set purge_vol = pv|map(attribute=to_tool)|max %}
        {% elif to_tool < 0 %}  # target tool unknown? find max purge value across all tools
           {action_respond_info("BLOBIFIER: tool(s) unknown. Finding largest value")}
           {% set purge_vol = pv|map('max')|max %}
        {% else %} # lookup and set specific purge value for transitioning from current to target tool  
           {% set purge_vol = pv[from_tool][to_tool]|float * purge_length_modifier %}
           {action_respond_info("BLOBIFIER: Swapped T%s > T%s" % (from_tool, to_tool))}
        {% endif %}
 
        {% set purge_len = purge_vol / filament_cross_section %}
        {% set purge_len = purge_len + printer.mmu.extruder_filament_remaining + park_vars.retracted_length + purge_length_addition %}
 
      {% else %}  # revert to default purge volume if nothing better provided
         {action_respond_info("BLOBIFIER: No toolmap or PURGE_LENGTH provided. Using default")}
         {% set purge_len = purge_length|float + printer.mmu.extruder_filament_remaining + park_vars.retracted_length %}
      {% endif %}
 
      # ==============================  APPLY PURGE MINIMUM  =================================
     
      {% set purge_len = [purge_len,purge_length_minimum]|max|round(0, 'ceil')|int %}
      {action_respond_info("BLOBIFIER: Purging %dmm of filament" % (purge_len))}
 
      # ===============================  PURGING SEQUENCE  ===================================
     
      G90 # absolute positioning.
      {% if purge_len|float > 0 %} # something to purge?
         BLOBIFIER_SAFE_PARK PURGING=True # move to blobifier and park up ready to purge
  
         {% if printer.extruder.temperature < purge_temp_min %} # heat HE if below minimum temp
            {% if printer.extruder.target < purge_temp_min %}
               M109 S{purge_temp_min}
            {% else %}
               TEMPERATURE_WAIT SENSOR=extruder MINIMUM={purge_temp_min}
            {% endif %}
         {% endif %}
 
         # ===============================  BLOBS AWAY!  ======================================
 
         # Calculate number of iterations based on the purge length and the max_iteration length.
         {% set blobs               = (purge_len / purge_length_maximum)|round(0, 'ceil')|int %}
         {% set purge_per_blob      = purge_len|float / blobs %}
         {% set retracts_per_blob   = (purge_per_blob / 40)|round(0, 'ceil')|int %}
         {% set purge_per_retract   = (purge_per_blob / retracts_per_blob)|int %}
         {% set pulses_per_retract  = (purge_per_blob / retracts_per_blob / 5)|round(0, 'ceil')|int %}
         {% set pulses_per_blob     = (purge_per_blob / 5)|round(0, 'ceil')|int %}
         {% set purge_per_pulse     = purge_per_blob / pulses_per_blob %}
         {% set pulse_time_constant = purge_per_pulse * 0.95 / (purge_spd * 60) / (purge_per_pulse * 0.95 / (purge_spd * 60) + purge_per_pulse * 0.05 / 50) %}
         {% set pulse_duration      = purge_per_pulse / (purge_spd * 60) %}
 
         SET_PRESSURE_ADVANCE ADVANCE=0 # disable PA for purge
 
         {% for blob in range(blobs) %} # repeat the process until purge_len is reached
            {action_respond_info("BLOBIFIER: Blob %d of %d (%.1fmm)" % (blob + 1, blobs, purge_per_blob))}
 
            {% if safe.tray or ignore_safe %}
               G1 Z{tray_top + purge_start} F{travel_spd_z * 60}
            {% endif %}
 
            G91 # relative positioning
            M83 # relative extrusion
 
            # Purge filament in a pulsating motion to purge the filament quicker and more effectively
            {% for pulse in range(pulses_per_blob) %}
               # Calculations to determine z-speed
               {% set purged_this_blob = pulse * purge_per_pulse %}
               {% set z_last_pos       = purge_start + ((purged_this_blob)/purge_length_maximum)**z_raise_exp * z_raise %}
               {% set z_pos            = purge_start + ((purged_this_blob + purge_per_pulse)/purge_length_maximum)**z_raise_exp * z_raise %}
               {% set z_up             = z_pos - z_last_pos %}
               {% set speed            = z_up / pulse_duration %}
 
               G1 Z{z_up * pulse_time_constant} E{purge_per_pulse * 0.95} F{speed}           # Purge quickly
               G1 Z{z_up * (1 - pulse_time_constant)} E{purge_per_pulse * 0.05} F{speed}     # Purge a tiny bit slowly
 
               {% if pulse % pulses_per_retract == 0 and pulse > 0 %}                        # retract and unretract filament every now and then for thorough cleaning
                  G1 E-2 F1800
                  G1 E2 F800
               {% endif %}
            {% endfor %}
 
            # Retract to match what Happy Hare is expecting
            G1 E-{park_vars.retracted_length} F{sequence_vars.retract_speed * 60}
       
           # ===============================  DEPOSIT BLOB  ===================================
 
           {% if safe.tray or ignore_safe %}
              G1 Z{eject_hop} F{travel_spd_z * 60}  # Raise z a bit to relieve pressure on the blob preventing it going sideways
              BLOBIFIER_SERVO POS=in  # Retract tray
 
              G4 P{pressure_release_time}
   
              # Move the toolhead down to purge_start height lowering the blob below the tray
              G90 #  absolute positioning
              G1 Z{tray_top} F{travel_spd_z * 60}
 
              # Extend the tray n-times to 'cut off' and detach the blob
              {% set iterations = tray_iterations if tray_iterations > 0 else 1 %}  # always default to 1
              {% for operations in range(iterations - 1) %}
                 BLOBIFIER_SERVO POS=out
                 BLOBIFIER_SERVO POS=in
              {% endfor %}
              BLOBIFIER_SERVO POS=out
 
              # shake nozzle to help detach belligerent blobs if required
              {% set nozzle_shake_x, nozzle_shakes = nozzle_shaker|map('float') %}
              {% if nozzle_shakes|int > 0 and nozzle_shake_x > 0 %}  
                 G91  # relative positioning
                 {% set direction = -1 if orientation == 1 else 1 %}
                 {% for shakes in range(nozzle_shakes|int) %}
                    G1 X{[nozzle_shake_x,5]|min * direction} F{travel_spd_xy * 60}          # move away from Blobifier, cap at 5mm
                    G1 X{[nozzle_shake_x,5]|min * (direction * -1)} F{travel_spd_xy * 60}   # move back to Blobifer
                 {% endfor %}
                 G90  # absolute positioning
              {% endif %}
 
              # Keep track of overall blobs
              _BLOBIFIER_COUNT
           {% endif %}
        {% endfor %}
 
        SET_PRESSURE_ADVANCE ADVANCE={printer.extruder.pressure_advance}  # restore PA
     {% endif %}
     
     # ===============================  WIPING OPTIONS  =================================
 
     G90 # absolute positioning.
     {% if static_wiper[0]|float > 0 and ((safe.tray and safe.brush) or ignore_safe) %}  # Static wiper and optional nozzle park?
         G1 Z{[tray_top + 1, static_wiper[2]]|max} F{travel_spd_z * 60}  # set Z height for move to wiper - whichever is higher
         G1 X{static_wiper[0]|float + (static_wiper[1]|float * orientation)} F{travel_spd_xy * 60}  # move to the start of the wiper for Blobifier orientation before final descent
         G1 Z{static_wiper[2]} F{travel_spd_z * 60}  # fine Z for wipe
 
         _BLOBIFIER_WIPER PARK_X={static_park[0]|float} PARK_H={static_park[1]|float} WIPE_X={static_wiper[0]|float} WIPE_W={static_wiper[1]|float} WIPES={static_wiper[4]|int} WIPE_ACTION={static_wiper[3]|int} AUTH={macro_auth}
     {% endif %}
 
     G1 Z{restore_z} F{travel_spd_z * 60}  #  restore Z prior to other wiping or parking actions
 
     {% if gantry_park > 0 or gantry_wiper[0]|float > 0 %}  # Gantry wipe and optional nozzle park next?
        _BLOBIFIER_WIPER PARK_X={gantry_park} WIPE_X={gantry_wiper[0]|float} WIPE_W={gantry_wiper[1]|float} WIPES={gantry_wiper[3]|int} WIPE_ACTION={gantry_wiper[2]|int} AUTH={macro_auth}
     {% endif %}
 
     {% if part_cooling_fan >= 0 %}  # restore part cooling fan if it was changed
        M106 S{printer.fan.speed * 255|int}
     {% endif %}
 
     M220 S{printer.gcode_move.speed_factor * 100|int}  # restore feedrate
  {% endif %}
 
  RESTORE_GCODE_STATE NAME=BLOBIFIER_state
 
 
############################################################################################
[gcode_macro BLOBIFIER_SAFE]  # alternate entry point for users with klicky probes that
# want to avoid probe / gantry collisions. Separate macro required to update probe status 
############################################################################################
 
gcode:
  {% set bl = printer['gcode_macro BLOBIFIER'] %}  # Blobifier user settings
  {% if printer["gcode_macro _User_Variables"].docklocation_x is defined or probe.docklocation_y is defined %}  # only check the probe status if we have a gantry
     {% if printer["gcode_macro _User_Variables"] is defined and bl.gantry_park > 0 or bl.gantry_wiper[0] > 0 %}  # do klicky macro variables exist  
         Query_Probe
         _SetProbeState 
     {% endif %}
  {% endif %}
 
   BLOBIFIER {rawparams}
 
############################################################################################
[gcode_macro BLOBIFIER_SAFE_PARK]  # alternate entry point for users with klicky probes that
# want to avoid probe / gantry collisions. Separate macro required to update probe status
############################################################################################
 
gcode:
  {% set bl = printer['gcode_macro BLOBIFIER'] %}  # Blobifier user settings
  {% if printer["gcode_macro _User_Variables"].docklocation_x is defined or probe.docklocation_y is defined %}  # only check the probe status if we have a gantry
     {% if printer["gcode_macro _User_Variables"] is defined and bl.gantry_park > 0 or bl.gantry_wiper[0] > 0 %}  # do klicky macro variables exist  
         Query_Probe
         _SetProbeState 
     {% endif %}
  {% endif %}
 
   BLOBIFIER_PARK {rawparams}
 
 
############################################################################################
[gcode_macro _BLOBIFIER_WIPER]  # Wipe the nozzle and park afterwards 
############################################################################################
 
gcode:
   {% set bl             = printer['gcode_macro BLOBIFIER'] %}     # Blobifier user settings
   {% set auth           = params.AUTH|default(0)|int %}           # manual execution check            
   {% set park_x         = params.PARK_X|default(-1)|float %}
   {% set park_h         = params.PARK_H|default(-1)|float %}      # park height    
   {% set wipe_x         = params.WIPE_X|default(-1)|float %}      
   {% set wipe_w         = params.WIPE_W|default(-1)|float %}
   {% set wipe_h         = params.WIPE_H|default(-1)|float %}      # wipe height
   {% set opposite       = params.OPPOSITE|default(1)|int %}       # finish at opposite end to optimise moves
   {% set wipes          = params.WIPES|default(1)|int %}          # number of wipes
   {% set wipe_action    = params.WIPE_ACTION|default(0)|int %}    # zigzag or normal wipe action
 
   {% set max_y          = printer.toolhead.axis_maximum.y - bl.skew_correction|float %}     
   {% set zigzag_y_sweep = 2 %}                                    # mm amplitude of zigzag peak
   {% set zigzag_step    = 8 %}                                    # mm size of zigzag step mm
   
   {% if auth != bl.macro_auth %}  # prevent certain macros from being run interactively from console
      {action_respond_info("BLOBIFIER: You cannot run this macro from the console")}
   {% elif "xyz" not in printer.toolhead.homed_axes or (printer.quad_gantry_level and printer.quad_gantry_level.applied == False) %}  
      {action_respond_info("BLOBIFIER: Not homed or QGL not applied! Please home xyz and QGL")}
   {% else %}
 
      M400
      SAVE_GCODE_STATE NAME=_BLOBIFIER_WIPER
      {% if bl.wipe_accel > 0 %}  # override accels if necessary
         SET_VELOCITY_LIMIT ACCEL={bl.wipe_accel} MINIMUM_CRUISE_RATIO=0.1  # set for warp speed!
      {% endif %}
          
      G90  # absolute positioning
      {% if printer.gcode_move.gcode_position.y != max_y %}  # reposition y & compensate for skew if needed
         G1 Y{max_y} F{bl.travel_spd_xy * 60}
      {% endif %}
 
      # ====================  ZIG ZAG & STRAIGHT WIPE PATTERNS  =========================
 
      {% if wipe_x > 0 and wipes > 0 %}  # valid wipe option?
         G1 X{wipe_x + wipe_w * bl.orientation} F{bl.travel_spd_xy * 60}  # move X to start of wiper based on orientation (on the left for LH setups, on the right for RH setups)   
         G91  # relative postioning
         {% if wipe_action == 1 or wipe_action == 2 %}                                                # zigzag wipe or combo zigzag/normal wipe (away from y start position)
            {% set spd_limit = bl.wipe_spd_xy if bl.wipe_spd_xy < 500 else 500 %}                     # cap zigzag speed @ 500mm/s to prevent damage
            {% set zigzags   = (wipe_w / zigzag_step)|int %}                                          # zig steps over width of wiper
            {% set wipe_for  = wipes if wipe_action == 1 else [1,(wipes * 0.4)|round|abs|int]|max %}  # if combo, set zigs to 40% of total wipes [min 1]
            {% set wipe_for  = wipe_for * 2 + 1 - bl.orientation + opposite if wipe_action == 1 else wipe_for|int * 2 + 1 - bl.orientation %} 
 
            {% for wipe in range(0 + (1 - bl.orientation), wipe_for|int) %}                           # set wipe range depending on orientation e.g [0..#] for LH, and [1..# + 1] for RH
               {% for zigzag in range(zigzags) %}  # full zigzag sweeps 
                  G1 X{wipe_w / (zigzags * 2) * (-1 if wipe % 2 == 0 else 1)} Y-{zigzag_y_sweep} F{spd_limit|int * 60}  # zig away from max_y
                  G1 X{wipe_w / (zigzags * 2) * (-1 if wipe % 2 == 0 else 1)} Y{zigzag_y_sweep}  F{spd_limit|int * 60}  # zag back
               {% endfor %}
            {% endfor %}
         {% endif %}
 
         {% if wipe_action == 0 or wipe_action == 2 %}                                                # straight line or combo wiping motion
            {% set wipe_for = wipes if wipe_action == 0 else [1,(wipes * 0.6)|round|abs|int]|max %}   # if combo, set straight wipes to 60% of total wipes, [min 1]
            {% for wipe in range(wipe_for) %}
               G1 X{wipe_w * (-1 if bl.orientation == 1 else 1)} F{bl.wipe_spd_xy * 60}               # wipe away
               G1 X{wipe_w * (1 if bl.orientation == 1 else -1)} F{bl.wipe_spd_xy * 60}               # wipe back
            {% endfor %}
            {% if opposite > 0 %}  # extra wipe to finish opposite start
               G1 X{wipe_w * (-1 if bl.orientation == 1 else 1)} F{bl.wipe_spd_xy * 60}
            {% endif %}
         {% endif %}
      {% endif %}        
 
      # ========================  INITIAL END OF WIPE PARK  =============================
 
      G90 # absolute positioning
      {% if park_x > 0 %}  # park up even if only temporarily
         {% if wipe_h > 0 and wipe_h < park_h %}  # z-hop if currently below park height
            G1 Z{park_h + 0.4} F{bl.travel_spd_z}
         {% endif %}
 
         G1 X{park_x} Y{max_y} F{bl.travel_spd_xy * 60}  # move to park_x
 
         {% if park_h != wipe_h and park_h > 0 and wipe_h > 0 %}  # drop to park  
            G1 Z{park_h} F{bl.travel_spd_z} 
         {% endif %}
      {% endif %}
 
      {% if bl.wipe_accel > 0 %} # restore accels if changed
         SET_VELOCITY_LIMIT ACCEL={printer.toolhead.max_accel} MINIMUM_CRUISE_RATIO={printer.toolhead.minimum_cruise_ratio}
      {% endif %}
 
      RESTORE_GCODE_STATE NAME=_BLOBIFIER_WIPER
   {% endif %}
   
 
############################################################################################
[gcode_macro BLOBIFIER_PARK] # evaluate and park at best available or purge location
############################################################################################
 
# Park nozzle at priority parking location or ready for purge
# 1) Gantry park wiper if fitted
# 2) Static park wiper if fitted
# 3) Else purge tray
 
# Enable this by setting Happy Hare post_form_tip extension in mmu_macro_vars.cfg:
#   variable_user_post_form_tip_extension: "BLOBIFIER_PARK"
 
variable_restore_z: 0 
 
gcode:
   {% set bl         = printer['gcode_macro BLOBIFIER'] %}
   {% set blc        = printer['gcode_macro _BLOBIFIER_COUNT'] %}
   {% set tc         = printer['gcode_macro _MMU_CUT_TIP_VARS'] %}
   {% set safe       = printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'] %} 
   {% set purging    = params.PURGING|default(false)|lower == 'true' %}  # set to true to force it to park on the tray for purging
   {% set y_pos      = printer.toolhead.axis_maximum.y - bl.skew_correction %}     
   {% set g2g        = True %}
 
   {% if "xyz" not in printer.toolhead.homed_axes or (printer.quad_gantry_level and printer.quad_gantry_level.applied == False) %}  # bail if not homed or QGL'd 
      {action_respond_info("BLOBIFIER: Not homed or QGL not applied! Please home xyz and QGL")}
      {% set g2g = False %}
   {% elif (bl.gantry_park > 0 or bl.gantry_wiper[0] > 0) and printer["gcode_macro _User_Variables"] is defined %}  # bail if gantry wipe / rest and klicky probe is attached to avoid collision   
      {% if printer["gcode_macro _Probe_Variables"].probe_attached %}
         {action_respond_info("BLOBIFIER: Unexpected Klicky probe attached! Please remove to avoid collision with gantry wiper / rest")}
         {% set g2g = False %}
      {% endif %}
   {% endif %} 
 
   # =========================  PRIORTISE PARKING SPOT  ==============================
 
   {% if g2g %}  # good to go ?
      {% if bl.gantry_park > 0 and not purging %}
         {% set park_x = bl.gantry_park %}
         {% set wipe_x, wipe_w, wipe_pattern, wipes = bl.gantry_wiper|map('float') %}
      {% elif bl.static_park[0] > 0 and not purging %}
         {% set park_x = bl.static_park[0] %}
         {% set wipe_x, wipe_w, wipe_height, wipe_pattern, wipes = bl.static_wiper|map('float') %}
      {% else %}  # tray it is
         {% set park_x = bl.purge_x %}
         {% set wipe_x, wipe_w, wipe_h = [0,0,0] %}
         BLOBIFIER_SERVO POS=out  # make sure tray is extended
      {% endif %}
 
      # =================================  PARK UP  =====================================
 
      G90 # absolute positioning.
      {% if park_x != printer.gcode_move.gcode_position.x or printer.gcode_move.gcode_position.y < y_pos %}  # if not already parked up, park
         M400
         SET_GCODE_VARIABLE MACRO=BLOBIFIER_PARK VARIABLE=restore_z VALUE={printer.gcode_move.gcode_position.z}
         SAVE_GCODE_STATE NAME=blobifier_park_state
 
         {% if bl.wipe_accel > 0 %}  # override accels if need be
            SET_VELOCITY_LIMIT ACCEL={bl.wipe_accel} MINIMUM_CRUISE_RATIO=0.1  # set for warp speed!
         {% endif %}
 
         {% if printer.gcode_move.gcode_position.z < [bl.clearance_z, bl.tray_top + 0.4]|max %}  # safety z-hop to minimum height before XY moves
            G1 Z{[bl.clearance_z, bl.tray_top + 0.4]|max} F{bl.travel_spd_z * 60}  # min z_hop floor
         {% endif %}
 
         # =========================  AVOID FILAMETRIX PIN  =============================
 
         # if tip cut enabled and in front of static filametrix pin (y), manoeuvre around it 
         {% if printer.configfile.config.mmu.form_tip_macro|upper == '_MMU_CUT_TIP' and not printer['gcode_macro _MMU_CUT_TIP_VARS'].gantry_servo_enabled and printer.gcode_move.gcode_position.y < tc.pin_loc_xy[1] %}
            {% set safe_x = [printer.toolhead.axis_minimum.x + bl.skew_correction + tc.pin_loc_xy[0] + tc.pin_park_dist + bl.toolhead_x|float,80]|max %}  # safety move margin (cap at 80mm)
            {% if printer.gcode_move.gcode_position.x < safe_x %}  # move inboard if needed
               G1 X{safe_x} F{bl.travel_spd_xy * 60} 
               {% if bl.orientation == 0 and tc.pin_loc_xy[1] > printer.gcode_move.gcode_position.y %}  # if LH side setup and depressor is behind us, move up beside it before final park/wipe move
                  G1 Y{tc.pin_loc_xy[1]} F{bl.travel_spd_xy * 60} 
               {% endif %}
            {% endif %}
         {% endif %}
 
         # ===============  POSITION AND MOVE THROUGH WIPER TO PARK  ====================
 
         {% if wipe_x > 0 and wipe_w > 0 %}  # if wiper specified, we want to position ourselves so we can park swiping through it to maximise the cleaning opportunity 
            {% if (park_x < wipe_x and printer.gcode_move.gcode_position.x < wipe_x + wipe_w or park_x > wipe_x and printer.gcode_move.gcode_position.x > wipe_x ) %}  # if coming from the wrong side, position just in front of wiper
;              G1 X{wipe_x + wipe_w * bl.orientation} Y{y_pos - 5} F{bl.travel_spd_xy * 60}  
               G1 X{wipe_x + (wipe_w if park_x < wipe_x else 0)} Y{y_pos - 5} F{bl.travel_spd_xy * 60}  
            {% endif %}
            G1 Y{y_pos} F{bl.travel_spd_xy * 60}  # line up with wiper centre
         {% else %}
            G1 X{park_x} Y{y_pos} F{bl.travel_spd_xy * 60}  # else move straight to designated xy parking spot
         {% endif %}
 
         # Descend for tray or static wiper / park if needed
         {% if (park_x == bl.purge_x and (safe.tray or ignore_safe)) or (park_x == bl.static_park[0] and (safe.brush or ignore_safe)) %}  # only descend if safe
            {% if bl.enable_shaker and park_x == bl.purge_x %} 
               {% if (blc.current_blobs + 1) >= blc.next_shake %}  # shake tray if needed 
                  BLOBIFIER_SHAKE_BUCKET SHAKES={bl.bucket_shakes} AUTH={bl.macro_auth}
                  _BLOBIFIER_CALCULATE_NEXT_SHAKE
               {% endif %}
            {% endif %}
            
            {% if wipe_x > 0 and wipe_w > 0 %}  # static wiper
               G1 Z{bl.static_wiper[2]} F{bl.travel_spd_z * 60}  # align with wiper level
;               G1 X{wipe_x + wipe_w * bl.orientation} F{bl.travel_spd_xy * 60}  # wipe through to end of wiper
               G1 X{wipe_x + (wipe_w if park_x < wipe_x else 0)} F{bl.travel_spd_xy * 60}  # wipe through to end of wiper
            {% endif %}
 
            {% set z_pos = bl.tray_top + (bl.purge_start if purging else 0) if park_x == bl.purge_x else bl.static_park[1] %}  # adjust height for purge or static park
            G1 Z{z_pos} F{bl.travel_spd_z * 60}
         {% endif %}
 
         G1 X{park_x} Y{y_pos} F{bl.travel_spd_xy * 60}  # finalise parking move
 
         {% if bl.wipe_accel > 0 %}  # restore accels if changed
            SET_VELOCITY_LIMIT ACCEL={printer.toolhead.max_accel} MINIMUM_CRUISE_RATIO={printer.toolhead.minimum_cruise_ratio}
         {% endif %}
 
         RESTORE_GCODE_STATE NAME=blobifier_park_state
      {% endif %}
   {% endif %}
 
 
############################################################################################
[gcode_macro BLOBIFIER_SERVO] # retract or extend the tray POS=[in|out]
############################################################################################
 
gcode:
  {% set bl  = printer['gcode_macro BLOBIFIER'] %}
  {% set pos = params.POS %}
 
  {% if pos == "in" %}
     SET_SERVO SERVO=blobifier ANGLE={bl.tray_angle_in}
     G4 P{bl.dwell_time}
  {% elif pos == "out" %}
     SET_SERVO SERVO=blobifier ANGLE={bl.tray_angle_out}
     G4 P{bl.dwell_time}
  {% else %}
     {action_respond_info("BLOBIFIER: provide POS=[in|out]")}
  {% endif %}
  SET_SERVO SERVO=blobifier WIDTH=0
 
 
############################################################################################
[gcode_macro EXCLUDE_OBJECT_DEFINE]  # override EXCLUDE_OBJECT_DEFINE so we can check if
# its safe to descend.
############################################################################################
 
rename_existing: _EXCLUDE_OBJECT_DEFINE
gcode:
  # only reset on the first object at the beginning of a print
  {% if printer.exclude_object.objects|length < 1 %}
     _BLOBIFIER_RESET_SAFE_DESCEND
  {% endif %}
  _EXCLUDE_OBJECT_DEFINE {rawparams}
  _BLOBIFIER_SAFE_DESCEND
  UPDATE_DELAYED_GCODE ID=BLOBIFIER_SHOW_SAFE_DESCEND DURATION=1
 
[delayed_gcode BLOBIFIER_SHOW_SAFE_DESCEND]
gcode:
  {% set safe = printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'] %}
  {action_respond_info(
    "BLOBIFIER: Safe descent possible:\n - tray   :  %s\n - wiper  :  %s\n - shaker :  %s" %
    (
      "yes" if safe.tray  else "no",
      "yes" if safe.brush else "no",
      "yes" if safe.shake else "no"
    )
  )}
 
 
############################################################################################
[gcode_macro EXCLUDE_OBJECT_START]  # override EXCLUDE_OBJECT_START to record and capture 
# the current height.
rename_existing: _EXCLUDE_OBJECT_START
############################################################################################
 
gcode:
  _EXCLUDE_OBJECT_START {rawparams}
  {% if printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'].first_layer %}
     SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=first_layer VALUE=False
     SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=print_height VALUE={printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'].print_layer_height}
  {% else %}
     {% set pos             = printer.gcode_move.gcode_position %}
     {% set last_height     = printer['gcode_macro _BLOBIFIER_SAFE_DESCEND'].print_previous_height|float %}
     {% if pos.z > last_height %}
        {% set last_layer   = (pos.z - last_height)|round(2) %}
        {% set print_height = (pos.z + last_layer)|round(2) %}
        SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=print_previous_height VALUE={pos.z}
        SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=print_height VALUE={print_height}
     {% endif %}
  {% endif %}
 
 
############################################################################################
[gcode_macro _BLOBIFIER_RESET_SAFE_DESCEND]  # Reset safe descend variables.
############################################################################################
 
gcode:
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=tray VALUE=True
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=brush VALUE=True
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=shake VALUE=True
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=first_layer VALUE=True
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=print_height VALUE=0
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=print_previous_height VALUE=0
 
 
############################################################################################
[gcode_macro _BLOBIFIER_SAFE_DESCEND]  # Determine if it's safe to lower the toolhead
# (e.g. not hit a print)
############################################################################################
 
variable_tray                  :  True # Assume it's safe
variable_brush                 :  True
variable_shake                 :  True
variable_first_layer           :  True
variable_print_height          :  0
variable_print_previous_height :  0
variable_print_layer_height    :  0.3
 
gcode:
 
  {% set bl    = printer['gcode_macro BLOBIFIER'] %}
  {% set max_y = printer.toolhead.axis_maximum.y - bl.skew_correction %}
 
  # ==========================  WORK OUT BLOBIFIER POLYGON  =============================
 
  {% set tray  = [bl.purge_x - bl.toolhead_x, max_y - bl.toolhead_y]     if bl.orientation == 1 else [bl.purge_x + bl.toolhead_x, max_y - bl.toolhead_y] %}
  {% set shake = [bl.purge_x - bl.toolhead_x, max_y - bl.toolhead_y - 4] if bl.orientation == 1 else [bl.purge_x + bl.toolhead_x, max_y - bl.toolhead_y - 4] %}
  {% if bl.static_park[0] > 0 or (bl.static_wiper[0] > 0 and bl.static_wiper[1] > 0) %}  # this is an optional feature so mask it if not installed
     {% set min_x = [bl.static_park[0] - bl.toolhead_x, bl.static_wiper[0] - bl.toolhead_x]|select("greaterthan",0)|min if bl.orientation == 1 else [bl.static_park[0] + bl.toolhead_x, bl.static_wiper[0] + bl.toolhead_x]|select("greaterthan",0)|max %}
     {% set brush = [min_x, max_y - bl.toolhead_y] %}
  {% else %}
     {% set brush = [-1,-1] %}
  {% endif %}
 
  # ======================  PARSE PRINT OBJECTS FOR COLLISIONS  =========================
 
  {% set objects = printer.exclude_object.objects | map(attribute='polygon') %}
  {% for polygon in objects %}  # loop though objects looking for intersections with blobifier shaker, tray, or static wiper / rest
     {% for point in polygon %}
        {% if (bl.orientation == 0 and point[0] < tray[0] and point[1] > tray[1]) or (bl.orientation == 1 and point[0] > tray[0] and point[1] > tray[1]) %}
          SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=tray VALUE=False
        {% endif %}
        {% if (bl.orientation == 0 and point[0] < brush[0] and point[1] > brush[1]) or (bl.orientation == 1 and point[0] > brush[0] and point[1] > brush[1]) %}
           SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=brush VALUE=False
        {% endif %}
        {% if (bl.orientation == 0 and point[0] < shake[0] and point[1] > shake[1]) or (bl.orientation == 1 and point[0] > shake[0] and point[1] > shake[1]) %}
           SET_GCODE_VARIABLE MACRO=_BLOBIFIER_SAFE_DESCEND VARIABLE=shake VALUE=False
        {% endif %}
      {% endfor %}
  {% endfor %}
 
 
############################################################################################
[gcode_macro _BLOBIFIER_COUNT]  # increment blob count & pause the print if bucket is full.
############################################################################################
 
# Don't change these variables
variable_current_blobs :  0
variable_last_shake    :  0
variable_next_shake    :  0
gcode:
  {% set bl    = printer['gcode_macro BLOBIFIER'] %}
  {% set count = printer['gcode_macro _BLOBIFIER_COUNT'] %}
 
  {% if current_blobs >= bl.max_blobs %}
     {action_respond_info("BLOBIFIER: Print paused, please empty the purge bucket!")}
     M117 Empty purge bucket!
     PAUSE
  {% else %}
     SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=current_blobs VALUE={current_blobs + 1}
     _BLOBIFIER_SAVE_STATE
     {action_respond_info(
        "BLOBIFIER: Blobs in bucket: %s/%s. Next shake @ %s"
        % (current_blobs + 1, bl.max_blobs, next_shake)
     )}
  {% endif %}
 
 
############################################################################################
[gcode_macro _BLOBIFIER_COUNT_RESET] # reset blob count to 0
############################################################################################
 
gcode:
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=current_blobs VALUE=0
  SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=last_shake VALUE=0
  _BLOBIFIER_SAVE_STATE
  _BLOBIFIER_CALCULATE_NEXT_SHAKE
 
 
############################################################################################
[gcode_macro BLOBIFIER_SHAKE_BUCKET]  # Shake the blob bucket to disperse the blobs
############################################################################################
 
gcode:
  {% set bl    = printer['gcode_macro BLOBIFIER'] %}
  {% set auth  = params.AUTH|default(0)|int %}           # manual execution check 
  {% set count = printer['gcode_macro _BLOBIFIER_COUNT'] %}
  {% set pos_x = (printer.toolhead.axis_minimum.x + bl.skew_correction if bl.orientation == 0 else printer.toolhead.axis_maximum.x - bl.skew_correction|float) %}
 
  {% if auth !=  bl.macro_auth %}  # prevent certain macros from being run interactively the from console
      {action_respond_info("BLOBIFIER: You cannot run this macro from the console")}
  {% elif "xyz" not in printer.toolhead.homed_axes or (printer.quad_gantry_level and printer.quad_gantry_level.applied == False) %}  
      {action_respond_info("BLOBIFIER: Not homed or QGL not applied! Please home xyz and QGL")}
  {% else %}
 
     SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=last_shake VALUE={count.current_blobs}
     _BLOBIFIER_SAVE_STATE
     SAVE_GCODE_STATE NAME=shake_bucket
            
     M400  # wait for current moves to finish
     M117 (^_^)
     BLOBIFIER_SERVO POS=in  # retract tray in case blobs are accumulating under it
 
     G90  # absolute positioning
     {% set shakes = params.SHAKES|default(10)|int %}
     {% set pos_y  = printer.toolhead.axis_maximum.y - bl.skew_correction|float %}
         
     {% if printer.toolhead.position.y != pos_y %}  # move to max_y and purge_x position ready to shake
        G1 X{bl.purge_x} Y{pos_y} F{bl.travel_spd_xy * 60}  
     {% endif %}
 
     G1 Z{bl.shaker_arm_z} F{bl.travel_spd_z * 60}  # hop up to engage shaker and prevent oozing on tray
     G1 X{pos_x} F{bl.travel_spd_xy * 60}.          # move and engage shaker
 
     M400  # wait for current moves to finish
     M117 (+(+_+)+)
 
     {% if bl.shake_accel > 0 %}  # override accels if need be
        SET_VELOCITY_LIMIT ACCEL={bl.shake_accel} MINIMUM_CRUISE_RATIO=0.1
     {% endif %}
 
     {% for shake in range(1, shakes) %}  # shake it baby, shake! (move away from max.y)
        G1 Y{pos_y - 4}
        G1 Y{pos_y}
     {% endfor %}
 
     {% if bl.shake_accel > 0 %}  # restore accels if changed
        SET_VELOCITY_LIMIT ACCEL={printer.toolhead.max_accel} MINIMUM_CRUISE_RATIO={printer.toolhead.minimum_cruise_ratio}
     {% endif%}
 
     BLOBIFIER_SERVO POS=out  # extend the tray ready for the next blob
     G1 X{bl.purge_x}  # move away from shaker and back to purge spot
 
     M400  # wait for current moves to finish
     M117 (X_x)
 
     RESTORE_GCODE_STATE NAME=shake_bucket 
  {% endif %}
  
 
############################################################################################
[gcode_macro _BLOBIFIER_CALCULATE_NEXT_SHAKE]  # Calculate next bucket shake.
############################################################################################
 
gcode:
  {% set bl    = printer['gcode_macro BLOBIFIER'] %}
  {% set count = printer['gcode_macro _BLOBIFIER_COUNT'] %}
 
  {% set remaining_blobs = bl.max_blobs - count.last_shake %}
  {% set next_shake      = (1 - bl.bucket_shake_frequency) * remaining_blobs + count.last_shake %}
  _BLOBIFIER_SAVE_STATE
  _BLOBIFIER_SET_NEXT_SHAKE VALUE={next_shake|int}
 
 
############################################################################################
[gcode_macro _BLOBIFIER_SET_NEXT_SHAKE]  # Set when the bucket should be shaken next
# VALUE=[int] At what amount of blobs it needs to it be shaken
############################################################################################
 
gcode:
  {% if params.VALUE %}
     {% set next_shake = params.VALUE %}
     SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=next_shake VALUE={next_shake}
     _BLOBIFIER_SAVE_STATE
  {% else %}
     {action_respond_info("BLOBIFIER: Provide parameter VALUE=")}
  {% endif %}
 
############################################################################################
[delayed_gcode BLOBIFIER_INIT]  # sanity checks
############################################################################################
 
initial_duration: 3.0
gcode:
 
  # automatically set orientation to optimise moves for LH and RH setups. If purge_x within 10% of max_x its RH else LH. Note set here rather than _blobifier_init in case it doesn't get set due to "soft" jinga2 data mapping errors 
  {% set orientation = 1 if printer['gcode_macro BLOBIFIER'].purge_x >= printer.toolhead.axis_maximum.x * 0.90 else 0 %}
  SET_GCODE_VARIABLE MACRO=BLOBIFIER VARIABLE=orientation VALUE={orientation}
 
  _BLOBIFIER_INIT
  BLOBIFIER_SERVO POS=out 
  
[gcode_macro _BLOBIFIER_INIT]
 
gcode:
 
  # ===========================  VALIDATE KEY USER SETTINGS  ==============================
 
  {% set bl = printer['gcode_macro BLOBIFIER'] %}
  SET_GCODE_VARIABLE MACRO=BLOBIFIER VARIABLE=macro_auth VALUE={(range(32768)|random)} # simple ephemeral auth check value to prevent users from executing certain macros from the command-line
 
  {% if bl.part_cooling_fan != -1 and (bl.part_cooling_fan < 0 or bl.part_cooling_fan > 1) %}  # valid part cooling fan setting
     {action_emergency_stop("BLOBIFIER: Value %f is invalid for part_cooling_fan. Either -1 or a value from 0 .. 1 is valid." % (bl.part_cooling_fan))}
  {% endif %}
 
  {% if bl.bucket_shake_frequency < 0 or bl.bucket_shake_frequency > 1 %}  # valid bucket shake frequency
     {action_emergency_stop("BLOBIFIER: Value %f is invalid for bucket_shake_frequency. Change it to a value between 0 .. 1" % (bl.bucket_shake_frequency))}
  {% endif %} 
 
  {% if printer.mmu %}
     {% if printer['gcode_macro _MMU_SEQUENCE_VARS'].restore_xy_pos != 'next' %}  # recommend setting restore)xy_pos to 'next'
        {action_respond_info("BLOBIFIER: If not using a wipe tower, consider setting restore_xy_pos: 'next' in mmu_macro_vars.cfg")}
     {% endif %}
  {% endif %}
 
  {% if bl.z_raise < 5 %}  # z_raise height reasonable
     {action_respond_info("BLOBIFIER: z_raise: %f is very low. This is the value z raises in total on a single blob. Make sure the value is correct before continuing." % (bl.z_raise))}
  {% endif %}
  
  {% if bl.z_raise_exp > 1 or bl.z_raise_exp < 0.5 %}  # Z raise exponent reasonable
     {action_respond_info("BLOBIFIER: z_raise_exp has value: %f. This value is out of spec (0.5 ... 1.0)." % (bl.z_raise))}
  {% endif %}
 
  
  {% if (orientation == 0 and bl.purge_x > 15) or (orientation == 1 and printer.toolhead.axis_maximum.x - bl.purge_x > 15) %}  # Valid purge_x position <= 15mm from outer edges of the print area
     {action_emergency_stop("BLOBIFIER: purge_x needs to be within 15mm of print area. Its set to %2.2fmm (%2.2fmm in from the edge)." % (bl.purge_x, bl.purge_x if orientation == 0 else printer.toolhead.axis_maximum.x - bl.purge_x))}
  {% endif %}
  
  # cap skew_correction at 1.0mm to minimise possible collisions (bed, endstop, etc) if the Blobifier tray is below bed height
  {% if bl.skew_correction < 0 and bl.skew_correction > 1.0 %}
     {action_respond_info("BLOBIFIER: skew_correction is: %f. This value is out of spec (0 ... 1.0). Resetting to 1.0." % (bl.skew_correction))}
     SET_GCODE_VARIABLE MACRO=BLOBIFIER VARIABLE=skew_correction VALUE=1.0
  {% endif %}
 
  {% if bl.shake_accel > printer.configfile.config.printer.max_accel|int %}  # warning if shake accels > printer max_accel
     {action_respond_info("BLOBIFIER: shake_accel is: %d which is higher than your printer max_accel limit of %d. Reduce this if your printer skips steps." % (bl.shake_accel,printer.configfile.config.printer.max_accel|int))}
  {% elif bl.shake_accel == 0 %}
     {action_respond_info("BLOBIFIER: overriding and setting shake_accel to your printers max_accel: %d." % (printer.configfile.config.printer.max_accel|int))}
     SET_GCODE_VARIABLE MACRO=BLOBIFIER VARIABLE=shake_accel VALUE={printer.configfile.config.printer.max_accel} 
  {% endif %}

  {% if bl.wipe_accel > printer.configfile.config.printer.max_accel|int %}  # warning if shake accels > printer max_accel
     {action_respond_info("BLOBIFIER: wipe_accel is: %d which is higher than your printer max_accel limit of %d. Reduce this if your printer skips steps." % (bl.wipe_accel,printer.configfile.config.printer.max_accel|int))}
  {% elif bl.wipe_accel == 0 %}
     {action_respond_info("BLOBIFIER: overriding and setting wipe_accel to your printers max_accel: %d." % (printer.configfile.config.printer.max_accel|int))}
     SET_GCODE_VARIABLE MACRO=BLOBIFIER VARIABLE=wipe_accel VALUE={printer.configfile.config.printer.max_accel} 
  {% endif %}
  
  # ==============================  PARK & WIPER SETTINGS  ================================
  
  {% set wipe_x, wipe_w, wipe_h, wipe_pattern, wipes = bl.static_wiper|map('float') %}  # map values instead of using irect list offsets for better error handling
  {% set park_x, park_h = bl.static_park|map('float') %}
 
  {% if park_x > 0 and park_h < 0 or park_h > 5 or (park_h - bl.tray_top)|abs > 5 %}  # static park height reasonable <= +/- 5mm from wiper
     {action_emergency_stop("BLOBIFIER: static_park height doesn't look right: %2.2fmm. It should be within +/- 5mm of wipe height. Please review and revise." % (park_h))}
 
  {% elif wipe_x > 0 and (wipe_w <= 0 or (wipe_pattern < 0 or wipe_pattern > 2)) %}  # other wiper settings reasonable - missing width, wipe pattern
     {action_emergency_stop("BLOBIFIER: static_wiper width and/or wipe pattern doesn't look right: %s. Please review and revise." % (bl.static_wiper))}
 
  {% elif park_x > 0 and wipe_x > 0 and park_x > wipe_x and park_x < wipe_x + wipe_w %}  # parking spot shouldn't be in the middle of the wiper 
     {action_emergency_stop("BLOBIFIER: static_park position is in the middle of your wiper: %2.2fmm >> %2.2fmm << %2.2fmm. Please review and revise." % (wipe_x, park_x, wipe_x + wipe_w))}
 
  {% elif park_x > 0 and wipe_x > 0 and ((bl.orientation == 1 and park_x > wipe_x) or (bl.orientation == 0 and park_x < wiper_x)) %}  # parking spot on the correct side of static wiper 
     {action_emergency_stop("BLOBIFIER: static_park position must be on the other side of the wiper: Parking @ %2.2fmm. Your wiper is %2.2fmm - %2.2fmm. Please review and revise." % (park_x, wipe_x, wipe_x + wipe_w))}
  {% endif %}
 
  {% set wipe_x, wipe_w, wipe_pattern, wipes = bl.gantry_wiper|map('float') %}  # map values instead of using direct list offsets for better error handling
  {% set park_x = bl.gantry_park %}
 
  {% if wipe_x > 0 and (wipe_w <= 0 or (wipe_pattern < 0 and wipe_pattern > 2)) %}  # check gantry wiper settings reasonable - missing width and wipe pattern
     {action_emergency_stop("BLOBIFIER: gantry_wiper width and/or wipe pattern doesn't look right : %s. Please review and revise." % (bl.gantry_wiper))}
 
  {% elif park_x > 0 and wipe_x > 0 and park_x > wipe_x and park_x < wipe_x + wipe_w %}  # parking spot shouldn't be in the middle of the wiper
    {action_emergency_stop("BLOBIFIER: gantry_park position is in the middle of your gantry wiper: %2.2fmm >> %2.2fmm << %2.2fmm. Please review and revise." % (wipe_x, park_x, wipe_x + wipe_w))}
 
  {% elif park_x > 0 and wipe_x > 0 and ((bl.orientation == 1 and park_x > wipe_x) or (bl.orientation == 0 and park_x < wipe_x)) %}  # parking spot must be on other side of wiper 
     {action_emergency_stop("BLOBIFIER: gantry_park position must be on the other side of the wiper: Parking @ %2.2fmm. Your wiper is %2.2fmm - %2.2fmm. Please review and revise." % (park_x, wipe_x, wipe_x + wipe_w))}
  {% endif %}
 
  {% if bl.nozzle_shaker[0]|float > 10 %}  # shaker moves reasonable <= 10mm 
     {action_emergency_stop("BLOBIFIER: nozzle_shaker x move should be <= 10mm: %s. Please review and revise." % (bl.nozzle_shaker[0]))}
  {% endif %}
 
   {% if bl.toolhead_x|float < 25 or bl.toolhead_y|float < 25 %}  # tool head dimensions reasonable for calculating safe descent and slicer exclusion options 
     {action_emergency_stop("BLOBIFIER: toolhead_x & toolhead_y safety clearance dimensions need to be reasonable: Currently set to %2.2fmm & %2.2fmm. Please review and revise." % (bl.toolhead_x, bl.toolhead_y))}
  {% endif %}
 
  # ==================  CALCULATE & DISPLAY SLICER EXCLUDED BED AREA  ====================
 
  {% set max_y = printer.toolhead.axis_maximum.y - bl.skew_correction %}
  {% set tray  = [bl.purge_x - bl.toolhead_x, max_y - bl.toolhead_y]     if bl.orientation == 1 else [bl.purge_x + bl.toolhead_x, max_y - bl.toolhead_y] %}
  {% set shake = [bl.purge_x - bl.toolhead_x, max_y - bl.toolhead_y - 4] if bl.orientation == 1 else [bl.purge_x + bl.toolhead_x, max_y - bl.toolhead_y - 4] %}
   
  {% if bl.static_park[0] > 0 or (bl.static_wiper[0] > 0 and bl.static_wiper[1] > 0) %}
     {% set min_x = [bl.static_park[0] - bl.toolhead_x, bl.static_wiper[0] - bl.toolhead_x]|select("greaterthan",0)|min if bl.orientation == 1 else [bl.static_park[0] + bl.toolhead_x, bl.static_wiper[0] + bl.toolhead_x]|select("greaterthan",0)|max %}
     {% set brush = [min_x, max_y - bl.toolhead_y] %}
  {% else %}
     {% set brush = [-1,-1] %}
  {% endif %}
 
  {% set slicer_x0 = [brush[0], tray[0], shake[0]]|select("greaterthan",0)|min|int if bl.orientation == 1 else 0 %}
  {% set slicer_x1 = [brush[0], tray[0], shake[0]]|select("greaterthan",0)|max|int if bl.orientation == 0 else printer.toolhead.axis_maximum.x %}
  {% set slicer_y  = [brush[1], tray[1], shake[1]]|select("greaterthan",0)|min|int %}
 
  {action_respond_info("BLOBIFIER: set your Slicer bed exclusion zone to: %dx%d, %dx%d, %dx%d, %dx%d" % (slicer_x0, slicer_y, slicer_x1, slicer_y, slicer_x1, printer.toolhead.axis_maximum.y, slicer_x0, printer.toolhead.axis_maximum.y))}
 
  
############################################################################################
[delayed_gcode BLOBIFIER_LOAD_STATE] # load persistent Blobifier values 
############################################################################################
 
initial_duration: 2.0 # Give it some time to boot up
gcode:
  {% set sv = printer.save_variables.variables.blobifier %}
 
  {% if sv %}
    # Restore state
    SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=last_shake VALUE={sv.last_shake}
    SET_GCODE_VARIABLE MACRO=_BLOBIFIER_COUNT VARIABLE=current_blobs VALUE={sv.current_blobs}
  {% endif %}
  _BLOBIFIER_CALCULATE_NEXT_SHAKE
 
 
############################################################################################
[gcode_macro _BLOBIFIER_SAVE_STATE]  # save persistent Blobifier values
############################################################################################
 
gcode:
  {% set count = printer['gcode_macro _BLOBIFIER_COUNT'] %}
  {% set sv = {'current_blobs': count.current_blobs, 'last_shake': count.last_shake} %}
  SAVE_VARIABLE VARIABLE=blobifier VALUE="{sv}"
 
 
